---
title: "Android Events"
description: "Understanding Helium Android SDK Events"
icon: "android"
---

## Overview

The Helium Android SDK provides a typed event system with sealed classes for better type safety and IDE support. The system offers strongly-typed event classes, excellent autocomplete, and comprehensive event tracking.

## Event Types

### Core Event Classes

```kotlin
// Base sealed class for all events
sealed class HeliumEvent(
    open val timestamp: Long
)

// Events with paywall context
sealed class PaywallContextEvent(
    override val timestamp: Long,
    open val triggerName: String,
    open val paywallName: String,
    open val isSecondTry: Boolean,
) : HeliumEvent(timestamp = timestamp)

// Product-related events
sealed class ProductEvent(
    override val timestamp: Long,
    override val triggerName: String,
    override val paywallName: String,
    override val isSecondTry: Boolean,
    open val productId: String,
) : PaywallContextEvent(
    timestamp = timestamp,
    triggerName = triggerName,
    paywallName = paywallName,
    isSecondTry = isSecondTry
)
```

## Listening to Events

### Via Delegate (Recommended)

Implement the `HeliumPaywallDelegate` interface with the `onHeliumPaywallEvent()` method:

```kotlin
class MyPaywallDelegate : HeliumPaywallDelegate {
    
    override suspend fun makePurchase(productId: String): HeliumPaywallTransactionStatus {
        // Your purchase implementation
        return HeliumPaywallTransactionStatus.Purchased
    }
    
    override suspend fun restorePurchases(): Boolean {
        // Your restore implementation
        return false
    }
    
    override fun onHeliumPaywallEvent(event: HeliumEvent) {
        // Type-safe event handling with when expression
        when (event) {
            is PaywallOpen -> {
                Log.d(TAG, "Paywall opened: ${event.paywallName}")
                Log.d(TAG, "Trigger: ${event.triggerName}")
                Log.d(TAG, "View type: ${event.viewType}")
                analytics.track("paywall_open", mapOf(
                    "triggerName" to event.triggerName,
                    "paywallName" to event.paywallName,
                    "viewType" to event.viewType
                ))
            }
            
            is PurchaseSucceeded -> {
                Log.d(TAG, "Purchase successful: ${event.productId}")
                updateUserSubscription(event.productId)
                event.storeKitTransactionId?.let { txnId ->
                    Log.d(TAG, "Transaction ID: $txnId")
                }
            }
            
            is PurchaseFailed -> {
                event.error?.let { error ->
                    Log.e(TAG, "Purchase failed: ${error.message}")
                    showErrorAlert(error)
                }
            }
            
            is PaywallDismissed -> {
                Log.d(TAG, "User dismissed paywall")
                if (event.dismissAll) {
                    Log.d(TAG, "All paywalls dismissed")
                }
            }
            
            is PaywallClose -> {
                Log.d(TAG, "Paywall closed")
                // Cleanup code here
            }
            
            else -> {
                Log.d(TAG, "Event: ${event::class.simpleName}")
            }
        }
    }
}
```

### Programmatic Presentation with Events

```kotlin
// Fragment or Activity example
class MyActivity : AppCompatActivity() {
    
    private val paywallDelegate = object : HeliumPaywallDelegate {
        override suspend fun makePurchase(productId: String): HeliumPaywallTransactionStatus {
            return handlePurchase(productId)
        }
        
        override suspend fun restorePurchases(): Boolean {
            return handleRestore()
        }
        
        override fun onHeliumPaywallEvent(event: HeliumEvent) {
            when (event) {
                is PaywallOpen -> {
                    logEvent("paywall_shown", mapOf(
                        "triggerName" to event.triggerName,
                        "paywallName" to event.paywallName
                    ))
                }
                is PurchaseSucceeded -> {
                    handleSuccessfulPurchase(event.productId)
                }
                is PaywallClose -> {
                    cleanupPaywallResources()
                }
                else -> { /* Handle other events */ }
            }
        }
    }
    
    fun showPaywall() {
        Helium.shared.launchPaywall(
            context = this,
            trigger = "premium_feature",
            delegate = paywallDelegate,
            customPaywallTraits = mapOf(
                "source" to "settings_menu",
                "user_tier" to "free",
                "days_since_install" to 7
            )
        )
    }
}
```

### Compose UI with Events

```kotlin
@Composable
fun PremiumScreen() {
    var showPaywall by remember { mutableStateOf(false) }
    
    val paywallDelegate = remember {
        object : HeliumPaywallDelegate {
            override suspend fun makePurchase(productId: String): HeliumPaywallTransactionStatus {
                return HeliumPaywallTransactionStatus.Purchased
            }
            
            override suspend fun restorePurchases(): Boolean = false
            
            override fun onHeliumPaywallEvent(event: HeliumEvent) {
                when (event) {
                    is PaywallOpen -> {
                        Log.d("Paywall", "Opened at ${event.timestamp}")
                    }
                    is PurchaseSucceeded -> {
                        Log.d("Paywall", "Purchase successful: ${event.productId}")
                        showPaywall = false
                    }
                    else -> { /* Handle other events */ }
                }
            }
        }
    }
    
    Button(onClick = { showPaywall = true }) {
        Text("Show Premium Features")
    }
    
    if (showPaywall) {
        HeliumPaywall(
            trigger = "premium_upgrade",
            delegate = paywallDelegate,
            customPaywallTraits = mapOf(
                "user_level" to getCurrentUserLevel(),
                "session_duration" to getSessionDuration()
            ),
            onDismiss = { showPaywall = false }
        )
    }
}
```

## Available Events

### Lifecycle Events

#### PaywallOpen
Paywall displayed to user.

**Properties:**
```kotlin
val event: PaywallOpen
event.triggerName         // String - Trigger identifier from dashboard
event.paywallName         // String - Template name
event.viewType            // PaywallOpenViewType - PRESENTED, TRIGGERED, or EMBEDDED
event.loadTimeTakenInMs   // Long? - Loading time in milliseconds
event.loadingBudgetInMs   // Long? - Loading budget in milliseconds
event.isSecondTry         // Boolean - Whether this is a second try paywall
event.timestamp           // Long - When event occurred (milliseconds)
```

**View Types:**
```kotlin
enum class PaywallOpenViewType {
    PRESENTED,  // Launched via launchPaywall
    TRIGGERED,  // Shown via Compose integration
    EMBEDDED    // Manually embedded in view
}
```

#### PaywallClose
Paywall closed (any reason).

**Properties:**
```kotlin
val event: PaywallClose
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template that was closed
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - When closed (milliseconds)
```

#### PaywallDismissed
User explicitly dismissed.

**Properties:**
```kotlin
val event: PaywallDismissed
event.triggerName     // String - Dismissed paywall trigger
event.paywallName     // String - Dismissed template
event.dismissAll      // Boolean - Whether entire stack dismissed
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Dismissal time (milliseconds)
```

#### PaywallOpenFailed
Failed to open paywall.

**Properties:**
```kotlin
val event: PaywallOpenFailed
event.triggerName     // String - Trigger that failed
event.paywallName     // String - Template that failed to open
event.error           // String - Error description
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Failure time (milliseconds)
```

#### PaywallSkipped
Paywall skipped (shouldShow=false).

**Properties:**
```kotlin
val event: PaywallSkipped
event.triggerName     // String - Trigger that was skipped
event.timestamp       // Long - When skipped (milliseconds)
```

#### PaywallButtonPressed
Non-purchase button pressed.

**Properties:**
```kotlin
val event: PaywallButtonPressed
event.buttonName      // String - Button identifier
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template containing button
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Press time (milliseconds)
```

#### PaywallWebViewRendered
WebView finished rendering.

**Properties:**
```kotlin
val event: PaywallWebViewRendered
event.triggerName                // String - Associated trigger
event.paywallName                // String - Template rendered
event.webviewRenderTimeTakenMS   // Long? - Time to render (ms)
event.isSecondTry                // Boolean - Whether this was a second try
event.timestamp                  // Long - Completion time (milliseconds)
```

### Purchase Events

#### ProductSelected
User selected a product.

**Properties:**
```kotlin
val event: ProductSelected
event.productId       // String - Google Play product ID
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where selected
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Selection time (milliseconds)
```

#### PurchasedPressed
Purchase initiated.

**Properties:**
```kotlin
val event: PurchasedPressed
event.productId       // String - Product being purchased
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where pressed
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Press time (milliseconds)
```

#### PurchaseSucceeded
Purchase completed.

**Properties:**
```kotlin
val event: PurchaseSucceeded
event.productId                       // String - Google Play product ID
event.triggerName                     // String - Associated trigger
event.paywallName                     // String - Template where purchased
event.storeKitTransactionId           // String? - Play Store transaction ID
event.storeKitOriginalTransactionId   // String? - Original transaction ID
event.skPostPurchaseTxnTimeMS         // Long? - Post-purchase processing time
event.isSecondTry                     // Boolean - Whether this was a second try
event.timestamp                       // Long - Completion time (milliseconds)
```

#### PurchaseCancelled
User cancelled purchase.

**Properties:**
```kotlin
val event: PurchaseCancelled
event.productId       // String - Product that was cancelled
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where cancelled
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Cancellation time (milliseconds)
```

#### PurchaseFailed
Purchase failed with error.

**Properties:**
```kotlin
val event: PurchaseFailed
event.productId       // String - Product that failed
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where failed
event.error           // Error? - Play Billing error object
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Failure time (milliseconds)
```

#### PurchaseRestored
Previous purchase restored.

**Properties:**
```kotlin
val event: PurchaseRestored
event.productId       // String - Restored product ID
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where restored
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Restoration time (milliseconds)
```

#### PurchaseRestoreFailed
Restore failed.

**Properties:**
```kotlin
val event: PurchaseRestoreFailed
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where failed
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - Failure time (milliseconds)
```

#### PurchasePending
Purchase pending (e.g., parental approval).

**Properties:**
```kotlin
val event: PurchasePending
event.productId       // String - Pending product
event.triggerName     // String - Associated trigger
event.paywallName     // String - Template where pending
event.isSecondTry     // Boolean - Whether this was a second try
event.timestamp       // Long - When became pending (milliseconds)
```

### System Events

#### InitializeStart
SDK initialization started.

**Properties:**
```kotlin
val event: InitializeStart
event.timestamp       // Long - Start time (milliseconds)
```

#### InitializeCalled
SDK initialization called with identity information.

**Properties:**
```kotlin
val event: InitializeCalled
event.timestamp           // Long - When called (milliseconds)
event.heliumPersistentID  // String? - Persistent device ID
event.heliumSessionID     // String? - Current session ID
```

#### PaywallsDownloadSuccess
Helium paywalls downloaded and initialized successfully.

**Properties:**
```kotlin
val event: PaywallsDownloadSuccess
event.downloadTimeTakenMS        // Long? - Total download time (ms)
event.imagesDownloadTimeTakenMS  // Long? - Image download time (ms)
event.fontsDownloadTimeTakenMS   // Long? - Font download time (ms)
event.bundleDownloadTimeMS       // Long? - Bundle download time (ms)
event.noOfAttempts               // Int? - Number of attempts made
event.timestamp                  // Long - Success time (milliseconds)
```

#### PaywallsDownloadError
Config download failed.

**Properties:**
```kotlin
val event: PaywallsDownloadError
event.error           // String - Error description
event.noOfAttempts    // Int? - Attempts made
event.timestamp       // Long - Failure time (milliseconds)
```

## Custom Paywall Traits

Pass dynamic context to paywalls at presentation time:

```kotlin
// Via Activity/Fragment
Helium.shared.launchPaywall(
    context = this,
    trigger = "game_over",
    delegate = paywallDelegate,
    customPaywallTraits = mapOf(
        "final_score" to gameState.score,
        "level" to gameState.currentLevel,
        "lives_remaining" to gameState.lives,
        "high_score" to userStats.bestScore,
        "session_length" to (System.currentTimeMillis() - sessionStart)
    )
)

// Via Compose
HeliumPaywall(
    trigger = "premium_feature",
    delegate = paywallDelegate,
    customPaywallTraits = mapOf(
        "user_level" to getCurrentUserLevel(),
        "feature_attempted" to "advanced_filters"
    ),
    onDismiss = { /* ... */ }
)

// Access in JavaScript within paywall template
const score = window.heliumContext.final_score;
const level = window.heliumContext.level;
```

## Event Handling Patterns

### Handling Event Hierarchies

Leverage sealed classes for efficient analytics:

```kotlin
override fun onHeliumPaywallEvent(event: HeliumEvent) {
    // Log all events
    analytics.track(event::class.simpleName ?: "unknown_event", mapEventToProperties(event))
    
    // Handle all events with paywall context
    if (event is PaywallContextEvent) {
        trackPaywallMetrics(
            trigger = event.triggerName,
            paywall = event.paywallName,
            isSecondTry = event.isSecondTry
        )
    }
    
    // Handle all product-related events
    if (event is ProductEvent) {
        validateProduct(productId = event.productId)
    }
}

private fun mapEventToProperties(event: HeliumEvent): Map<String, Any?> {
    return when (event) {
        is PaywallContextEvent -> mapOf(
            "triggerName" to event.triggerName,
            "paywallName" to event.paywallName,
            "isSecondTry" to event.isSecondTry,
            "timestamp" to event.timestamp
        )
        is PaywallSkipped -> mapOf(
            "triggerName" to event.triggerName,
            "timestamp" to event.timestamp
        )
        else -> mapOf("timestamp" to event.timestamp)
    }
}
```

### Filtering Events

```kotlin
override fun onHeliumPaywallEvent(event: HeliumEvent) {
    // Only track purchase-related events
    when (event) {
        is PurchasedPressed,
        is PurchaseSucceeded,
        is PurchaseFailed,
        is PurchaseCancelled,
        is PurchasePending -> {
            trackPurchaseEvent(event as ProductEvent)
        }
        else -> {
            // Ignore other events
        }
    }
}
```

### Coroutine-Safe Event Handling

```kotlin
class MyDelegate(
    private val scope: CoroutineScope
) : HeliumPaywallDelegate {
    
    override fun onHeliumPaywallEvent(event: HeliumEvent) {
        // Launch coroutines for async operations
        scope.launch {
            when (event) {
                is PurchaseSucceeded -> {
                    // Async operations
                    syncPurchaseToBackend(event.productId)
                    updateLocalDatabase(event)
                }
                is PaywallOpen -> {
                    trackEventAsync(event)
                }
                else -> { /* ... */ }
            }
        }
    }
    
    private suspend fun syncPurchaseToBackend(productId: String) {
        // Network call
        withContext(Dispatchers.IO) {
            api.syncPurchase(productId)
        }
    }
}
```

## Event Handling Notes

- All timestamps are in milliseconds (Unix epoch)
- `PaywallDismissed` fires when user explicitly closes without purchasing
- `PaywallClose` fires after both dismissal and successful purchase for cleanup
- Custom traits are cleared automatically when paywall closes
- Sealed class hierarchy enables exhaustive when expressions
- Events are dispatched on the main thread

## Using Events for Analytics

### Complete Analytics Integration

```kotlin
class AnalyticsPaywallDelegate(
    private val analytics: AnalyticsService
) : HeliumPaywallDelegate {
    
    override suspend fun makePurchase(productId: String): HeliumPaywallTransactionStatus {
        // Your purchase logic
        return HeliumPaywallTransactionStatus.Purchased
    }
    
    override suspend fun restorePurchases(): Boolean {
        return false
    }
    
    override fun onHeliumPaywallEvent(event: HeliumEvent) {
        val eventName = when (event) {
            is InitializeStart -> "helium_initialize_start"
            is InitializeCalled -> "helium_initialize_called"
            is PaywallOpen -> "helium_paywall_open"
            is PaywallClose -> "helium_paywall_close"
            is PaywallDismissed -> "helium_paywall_dismissed"
            is PaywallOpenFailed -> "helium_paywall_open_failed"
            is PaywallSkipped -> "helium_paywall_skipped"
            is PaywallButtonPressed -> "helium_button_pressed"
            is PaywallWebViewRendered -> "helium_webview_rendered"
            is ProductSelected -> "helium_product_selected"
            is PurchasedPressed -> "helium_purchase_pressed"
            is PurchaseSucceeded -> "helium_purchase_succeeded"
            is PurchaseCancelled -> "helium_purchase_cancelled"
            is PurchaseFailed -> "helium_purchase_failed"
            is PurchaseRestored -> "helium_purchase_restored"
            is PurchaseRestoreFailed -> "helium_restore_failed"
            is PurchasePending -> "helium_purchase_pending"
            is PaywallsDownloadSuccess -> "helium_download_success"
            is PaywallsDownloadError -> "helium_download_error"
        }
        
        val properties = buildMap<String, Any> {
            put("timestamp", event.timestamp)
            
            when (event) {
                is PaywallContextEvent -> {
                    put("trigger_name", event.triggerName)
                    put("paywall_name", event.paywallName)
                    put("is_second_try", event.isSecondTry)
                }
                is PaywallSkipped -> {
                    put("trigger_name", event.triggerName)
                }
                else -> { /* Base timestamp only */ }
            }
            
            // Add event-specific properties
            when (event) {
                is ProductEvent -> put("product_id", event.productId)
                is PaywallOpen -> {
                    put("view_type", event.viewType.name)
                    event.loadTimeTakenInMs?.let { put("load_time_ms", it) }
                }
                is PurchaseSucceeded -> {
                    event.storeKitTransactionId?.let { put("transaction_id", it) }
                }
                is PurchaseFailed -> {
                    event.error?.message?.let { put("error", it) }
                }
                is PaywallsDownloadSuccess -> {
                    event.downloadTimeTakenMS?.let { put("download_time_ms", it) }
                    event.noOfAttempts?.let { put("num_attempts", it) }
                }
                else -> { /* No additional properties */ }
            }
        }
        
        analytics.track(eventName, properties)
    }
}
```

## Performance Monitoring

Several events include timing information for performance monitoring:

```kotlin
override fun onHeliumPaywallEvent(event: HeliumEvent) {
    when (event) {
        is PaywallsDownloadSuccess -> {
            val totalTime = event.downloadTimeTakenMS ?: 0
            val imageTime = event.imagesDownloadTimeTakenMS ?: 0
            val fontTime = event.fontsDownloadTimeTakenMS ?: 0
            val bundleTime = event.bundleDownloadTimeMS ?: 0
            
            logPerformance("Paywall Download", mapOf(
                "total_ms" to totalTime,
                "images_ms" to imageTime,
                "fonts_ms" to fontTime,
                "bundle_ms" to bundleTime,
                "attempts" to (event.noOfAttempts ?: 1)
            ))
        }
        
        is PaywallWebViewRendered -> {
            event.webviewRenderTimeTakenMS?.let { renderTime ->
                logPerformance("WebView Render", mapOf(
                    "render_ms" to renderTime,
                    "paywall" to event.paywallName
                ))
            }
        }
        
        is PaywallOpen -> {
            event.loadTimeTakenInMs?.let { loadTime ->
                logPerformance("Paywall Load", mapOf(
                    "load_ms" to loadTime,
                    "budget_ms" to (event.loadingBudgetInMs ?: 0)
                ))
            }
        }
        
        else -> { /* Other events */ }
    }
}
```

Use this data to identify bottlenecks and optimize user experience.

## Best Practices

### 1. Implement Proper Lifecycle Management

```kotlin
class MyActivity : AppCompatActivity() {
    private val paywallDelegate = MyPaywallDelegate()
    
    override fun onDestroy() {
        super.onDestroy()
        // Clean up any event listeners or resources
        paywallDelegate.cleanup()
    }
}
```

### 2. Handle Events Asynchronously

```kotlin
override fun onHeliumPaywallEvent(event: HeliumEvent) {
    lifecycleScope.launch {
        when (event) {
            is PurchaseSucceeded -> {
                withContext(Dispatchers.IO) {
                    // Heavy operation off main thread
                    syncPurchaseToBackend(event)
                }
            }
            else -> { /* ... */ }
        }
    }
}
```

### 3. Use Structured Logging

```kotlin
private fun logEvent(event: HeliumEvent) {
    val eventClass = event::class.simpleName ?: "Unknown"
    
    when (event) {
        is PaywallContextEvent -> {
            Log.d(TAG, """
                Event: $eventClass
                Trigger: ${event.triggerName}
                Paywall: ${event.paywallName}
                IsSecondTry: ${event.isSecondTry}
                Timestamp: ${event.timestamp}
            """.trimIndent())
        }
        else -> {
            Log.d(TAG, "Event: $eventClass at ${event.timestamp}")
        }
    }
}
```

### 4. Implement Error Handling

```kotlin
override fun onHeliumPaywallEvent(event: HeliumEvent) {
    try {
        when (event) {
            is PurchaseFailed -> handlePurchaseError(event)
            is PaywallOpenFailed -> handlePaywallError(event)
            is PaywallsDownloadError -> handleDownloadError(event)
            else -> handleSuccessEvent(event)
        }
    } catch (e: Exception) {
        Log.e(TAG, "Error handling event: ${event::class.simpleName}", e)
        crashlytics.recordException(e)
    }
}
```

