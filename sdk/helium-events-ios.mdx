---
title: "iOS Events"
description: "Understanding Helium iOS SDK Events"
icon: "apple"
---

## Overview

The Helium SDK provides a typed event system with type-safe, protocol-based events for better IDE support and cleaner code. The system offers strongly-typed event structs, better autocomplete, and comprehensive event tracking.

## Event Types

### Core Event Protocols

```swift
// Base protocol for all events
protocol PaywallEvent {
    var eventName: String { get }
    var timestamp: Date { get }
    func toDictionary() -> [String: Any]
}

// Events with paywall context
protocol PaywallContextEvent: PaywallEvent {
    var triggerName: String { get }
    var paywallName: String { get }
}

// Product-related events
protocol ProductEvent: PaywallContextEvent {
    var productId: String { get }
}
```

## Listening to Events

### Method 1: Via Delegate (Recommended)

Implement the `HeliumPaywallDelegate` protocol with the `onPaywallEvent(_:)` method:

```swift
class MyPaywallDelegate: HeliumPaywallDelegate {
    
    func makePurchase(productId: String) async -> HeliumPaywallTransactionStatus {
        // Your purchase implementation
        return .purchased
    }
    
    func restorePurchases() async -> Bool {
        // Your restore implementation
        return false
    }
    
    func onPaywallEvent(_ event: PaywallEvent) {
        // Type-safe event handling with pattern matching
        switch event {
        case let openEvent as PaywallOpenEvent:
            print("Paywall opened: \(openEvent.paywallName)")
            print("Trigger: \(openEvent.triggerName)")
            print("View type: \(openEvent.viewType)")
            analytics.track("paywall_open", properties: openEvent.toDictionary())
            
        case let purchaseSuccess as PurchaseSucceededEvent:
            print("Purchase successful: \(purchaseSuccess.productId)")
            updateUserSubscription(purchaseSuccess.productId)
            
        case let purchaseFailed as PurchaseFailedEvent:
            if let error = purchaseFailed.error {
                print("Purchase failed: \(error.localizedDescription)")
                showErrorAlert(error)
            }
            
        case let dismissed as PaywallDismissedEvent:
            print("User dismissed paywall")
            if dismissed.dismissAll {
                print("All paywalls dismissed")
            }
            
        case let closeEvent as PaywallCloseEvent:
            print("Paywall closed")
            // Cleanup code here
            
        default:
            print("Event: \(event.eventName)")
        }
    }
}
```

### Method 2: Via PaywallEventService (for triggerUpsell)

Use the `PaywallEventService` with a builder pattern for inline event handling:

```swift
struct ContentView: View {
    @State private var showPaywall = false
    
    var body: some View {
        Button("Show Premium Features") {
            showPaywall = true
        }
        .triggerUpsell(
            isPresented: $showPaywall,
            trigger: "premium_upgrade",
            eventService: PaywallEventService()
                .onOpen { event in
                    print("Paywall opened at \(event.timestamp)")
                    analytics.track("paywall_impression", [
                        "trigger": event.triggerName,
                        "paywall": event.paywallName,
                        "viewType": event.viewType.rawValue
                    ])
                }
                .onDismissed { event in
                    print("User dismissed without purchasing")
                    analytics.track("paywall_dismissed", [
                        "trigger": event.triggerName
                    ])
                }
                .onPurchaseSucceeded { event in
                    print("Purchase successful: \(event.productId)")
                    userDefaults.set(true, forKey: "isPremium")
                    showSuccessMessage()
                }
                .onClose { event in
                    print("Paywall closed, cleanup resources")
                    resetPaywallState()
                },
            customPaywallTraits: [
                "user_level": getCurrentUserLevel(),
                "session_duration": getSessionDuration(),
                "feature_attempted": "advanced_filters"
            ]
        )
    }
}
```

### Method 3: Programmatic Presentation with Events

```swift
// UIKit example with event service
func showPaywall() {
    let eventService = PaywallEventService()
        .onOpen { event in
            logEvent("paywall_shown", event.toDictionary())
        }
        .onPurchaseSucceeded { event in
            handleSuccessfulPurchase(event.productId)
        }
        .onClose { event in
            cleanupPaywallResources()
        }
    
    Helium.shared.presentUpsell(
        trigger: "premium_feature",
        from: self,
        eventService: eventService,
        customPaywallTraits: [
            "source": "settings_menu",
            "user_tier": "free",
            "days_since_install": 7
        ]
    )
}
```

## Available Events

### Lifecycle Events

#### PaywallOpenEvent
Paywall displayed to user.

```swift
let event: PaywallOpenEvent
// Properties:
event.triggerName     // Trigger identifier from dashboard
event.paywallName     // Template name
event.viewType        // .presented, .triggered, or .embedded
event.timestamp       // When event occurred
```

#### PaywallCloseEvent
Paywall closed (any reason).

```swift
let event: PaywallCloseEvent
event.triggerName     // Associated trigger
event.paywallName     // Template that was closed
event.timestamp       // When closed
```

#### PaywallDismissedEvent
User explicitly dismissed.

```swift
let event: PaywallDismissedEvent
event.triggerName     // Dismissed paywall trigger
event.paywallName     // Dismissed template
event.dismissAll      // Whether entire stack dismissed
event.timestamp       // Dismissal time
```

#### PaywallOpenFailedEvent
Failed to open paywall.

```swift
let event: PaywallOpenFailedEvent
event.triggerName     // Trigger that failed
event.paywallName     // Template that failed to open
event.timestamp       // Failure time
```

#### PaywallSkippedEvent
Paywall skipped (shouldShow=false).

```swift
let event: PaywallSkippedEvent
event.triggerName     // Trigger that was skipped
event.timestamp       // When skipped
```

#### PaywallButtonPressedEvent
Non-purchase button pressed.

```swift
let event: PaywallButtonPressedEvent
event.buttonName      // Button identifier
event.triggerName     // Associated trigger
event.paywallName     // Template containing button
event.timestamp       // Press time
```

#### PaywallWebViewRenderedEvent
WebView finished rendering.

```swift
let event: PaywallWebViewRenderedEvent
event.triggerName     // Associated trigger
event.paywallName     // Template rendered
event.renderTime      // Time to render (ms)
event.timestamp       // Completion time
```

### Purchase Events

#### ProductSelectedEvent
User selected a product.

```swift
let event: ProductSelectedEvent
event.productId       // StoreKit product ID
event.triggerName     // Associated trigger
event.paywallName     // Template where selected
event.timestamp       // Selection time
```

#### PurchasePressedEvent
Purchase initiated.

```swift
let event: PurchasePressedEvent
event.productId       // Product being purchased
event.triggerName     // Associated trigger
event.paywallName     // Template where pressed
event.timestamp       // Press time
```

#### PurchaseSucceededEvent
Purchase completed.

```swift
let event: PurchaseSucceededEvent
event.productId       // StoreKit product ID
event.triggerName     // Associated trigger
event.paywallName     // Template where purchased
event.timestamp       // Completion time
```

#### PurchaseCancelledEvent
User cancelled purchase.

```swift
let event: PurchaseCancelledEvent
event.productId       // Product that was cancelled
event.triggerName     // Associated trigger
event.paywallName     // Template where cancelled
event.timestamp       // Cancellation time
```

#### PurchaseFailedEvent
Purchase failed with error.

```swift
let event: PurchaseFailedEvent
event.productId       // Product that failed
event.triggerName     // Associated trigger
event.paywallName     // Template where failed
event.error           // StoreKit error object
event.timestamp       // Failure time
```

#### PurchaseRestoredEvent
Previous purchase restored.

```swift
let event: PurchaseRestoredEvent
event.productId       // Restored product ID
event.triggerName     // Associated trigger
event.paywallName     // Template where restored
event.timestamp       // Restoration time
```

#### PurchaseRestoreFailedEvent
Restore failed.

```swift
let event: PurchaseRestoreFailedEvent
event.triggerName     // Associated trigger
event.paywallName     // Template where failed
event.timestamp       // Failure time
```

#### PurchasePendingEvent
Purchase pending (e.g., parental approval).

```swift
let event: PurchasePendingEvent
event.productId       // Pending product
event.triggerName     // Associated trigger
event.paywallName     // Template where pending
event.timestamp       // When became pending
```

### Experiment Events

#### UserAllocatedEvent
Fired once per trigger when a user is allocated to an experiment variant and the paywall is first shown.

**Properties:**
```swift
let event: UserAllocatedEvent
event.experimentInfo  // Complete experiment allocation data (ExperimentInfo)
event.timestamp       // When allocation occurred (Date)
event.eventName       // "userAllocated"
```

**ExperimentInfo Structure:**

The `experimentInfo` object contains complete allocation data organized into several categories:

##### Core Experiment Data
```swift
event.experimentInfo.trigger          // String - Trigger name that was allocated
event.experimentInfo.experimentName   // String? - Human-readable experiment name
event.experimentInfo.experimentId     // String? - Unique experiment identifier
event.experimentInfo.experimentType   // String? - Type (e.g., "A/B/n test", "MAB")
```

##### Targeting Information
```swift
event.experimentInfo.audienceId              // String? - Audience ID that user matched
event.experimentInfo.audienceDataDictionary  // [String: Any]? - Parsed audience rules/criteria
```

The `audienceDataDictionary` contains targeting logic:
- `operator` - How rules are combined ("AND", "OR")
- `isAllUsers` - Whether this targets all users
- `rules` - Array of targeting rules that matched

##### Allocation Metadata
```swift
event.experimentInfo.allocationMetadataDictionary  // [String: Any]? - Custom metadata from dashboard
```

Use this field to store custom experiment notes, tags, or configuration that you want available at runtime.

##### Variant Details
```swift
event.experimentInfo.chosenVariantDetails?.allocationName   // String? - Variant/paywall name
event.experimentInfo.chosenVariantDetails?.allocationId     // String? - Variant UUID
event.experimentInfo.chosenVariantDetails?.allocationIndex  // Int? - Variant number (1-indexed)
event.experimentInfo.chosenVariantDetails?.allocationTime   // Date - When allocated
```

The `allocationIndex` is 1-indexed (1, 2, 3, ...) corresponding to the variant number shown to the user.

##### Hash Details
```swift
event.experimentInfo.hashDetails?.hashedUserIdBucket1To100  // Int? - User's hash bucket (1-100)
event.experimentInfo.hashDetails?.hashedUserId              // String? - ID that was hashed
event.experimentInfo.hashDetails?.hashMethod                // String? - Hash method used
```

**Hash Methods:**
- `"HASH_USER_ID"` - Standard user ID hashing
- `"HASH_HELIUM_PERSISTENT_ID"` - Persistent device ID hashing (more stable across reinstalls)

The `hashedUserIdBucket1To100` is a deterministic value (1-100) used for consistent variant assignment.

**Complete Example:**
```swift
case let allocated as UserAllocatedEvent:
    let info = allocated.experimentInfo
    
    // Basic info
    print("Trigger: \(info.trigger)")
    print("Experiment: \(info.experimentName ?? "unknown")")
    print("Variant #\(info.chosenVariantDetails?.allocationIndex ?? 0)")
    
    // Bucketing info
    if let hash = info.hashDetails {
        print("Hash bucket: \(hash.hashedUserIdBucket1To100 ?? 0)/100")
        print("Hash method: \(hash.hashMethod ?? "default")")
    }
    
    // Targeting info
    if let audienceId = info.audienceId {
        print("Matched audience: \(audienceId)")
        if let rules = info.audienceDataDictionary {
            print("Targeting rules: \(rules)")
        }
    }
    
    // Custom metadata
    if let metadata = info.allocationMetadataDictionary {
        print("Metadata: \(metadata)")
    }
    
    // Send to custom analytics with full context
    analytics.track("experiment_allocated", properties: [
        "experiment_id": info.experimentId ?? "",
        "experiment_name": info.experimentName ?? "",
        "variant_index": info.chosenVariantDetails?.allocationIndex ?? 0,
        "variant_name": info.chosenVariantDetails?.allocationName ?? "",
        "hash_bucket": info.hashDetails?.hashedUserIdBucket1To100 ?? 0,
        "hash_method": info.hashDetails?.hashMethod ?? "default",
        "audience_id": info.audienceId ?? ""
    ])
```

**When This Event Fires:**
- Only fires once per trigger per session (idempotent)
- Fires when a non-fallback paywall is first shown
- Does NOT fire for fallback paywalls
- Does NOT fire for triggers without experiments
- Tracked by `ExperimentAllocationTracker` to ensure one-time firing

**Use Cases:**
- Track experiment exposure for analysis
- Log variant assignments to your data warehouse
- Implement custom experiment tracking
- Debug allocation issues
- Monitor experiment distribution

### System Events

#### InitializeStartEvent
SDK initialization started.

```swift
let event: InitializeStartEvent
event.timestamp       // Start time
```

#### PaywallsDownloadSuccessEvent
Helium paywalls downloaded and initialized successfully.

```swift
let event: PaywallsDownloadSuccessEvent
event.downloadTime    // Total download time (ms)
event.numAttempts     // Number of attempts made
event.timestamp       // Success time
```

#### PaywallsDownloadErrorEvent
Config download failed.

```swift
let event: PaywallsDownloadErrorEvent
event.error           // Error description
event.numAttempts     // Attempts made
event.timestamp       // Failure time
```

## Custom Paywall Traits

You can pass pass dynamic context to paywalls at presentation time:

```swift
// Set during presentation
.triggerUpsell(
    isPresented: $showPaywall,
    trigger: "game_over",
    customPaywallTraits: [
        "final_score": gameState.score,
        "level": gameState.currentLevel,
        "lives_remaining": gameState.lives,
        "high_score": userStats.bestScore,
        "session_length": Date().timeIntervalSince(sessionStart)
    ]
)

// Access in JavaScript within paywall template
const score = window.heliumContext.final_score;
const level = window.heliumContext.level;
```

## Event Handling Notes

- `onDismissed` fires when user explicitly closes without purchasing
- `onClose` fires after both dismissal and successful purchase for cleanup
- Custom traits are cleared automatically when paywall closes
- Protocol conformance enables handling groups of related events

## Using Events for Analytics

Leverage protocol conformance for efficient analytics:

```swift
func onPaywallEvent(_ event: PaywallEvent) {
    // Log all events
    analytics.track(event.eventName, properties: event.toDictionary())
    
    // Handle all events with paywall context
    if let contextEvent = event as? PaywallContextEvent {
        trackPaywallMetrics(
            trigger: contextEvent.triggerName,
            paywall: contextEvent.paywallName
        )
    }
    
    // Handle all product-related events
    if let productEvent = event as? ProductEvent {
        validateProduct(productId: productEvent.productId)
    }
}
```

## Performance Monitoring

Several events include timing information for performance monitoring:

- `PaywallsDownloadSuccessEvent` - Configuration download times
- `PaywallWebViewRenderedEvent` - WebView render times

Use this data to identify bottlenecks and optimize user experience.

---

## Legacy 2.x Events

<Note>
The following section documents the legacy event system from SDK version 2.x. For new implementations, use the current event system described above.
</Note>

### Legacy Event Handling

The 2.x system uses the `onHeliumPaywallEvent` method with an enum-based approach:

```swift
func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
    switch (event) {
    case .paywallOpen(let triggerName, let paywallTemplateName, let viewType):
        print("Paywall opened: \(triggerName), template: \(paywallTemplateName), viewType: \(viewType)")
    case .subscriptionSucceeded(let productKey, let triggerName, let paywallTemplateName):
        print("Subscription succeeded for product: \(productKey)")
    // Handle other events as needed
    default:
        break
    }
}
```

### Initialization Events

#### Initialize Start
```swift
case initializeStart
```
Triggered when the Helium SDK initialization process begins.

### User Interaction Events

#### CTA Pressed
```swift
case ctaPressed(ctaName: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a user presses a Call-To-Action (CTA) button on the paywall.

#### Offer Selected
```swift
case offerSelected(productKey: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a user selects a specific offer or product.

#### Subscription Pressed
```swift
case subscriptionPressed(productKey: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a user presses the subscribe button for a specific product.

### Subscription Status Events

#### Subscription Cancelled
```swift
case subscriptionCancelled(productKey: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a subscription process is cancelled by the user.

#### Subscription Succeeded
```swift
case subscriptionSucceeded(productKey: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a subscription is successfully completed.

#### Subscription Failed
```swift
case subscriptionFailed(productKey: String, triggerName: String, paywallTemplateName: String, error: String? = nil)
```
Triggered when the subscription process fails for any reason.

#### Subscription Restored
```swift
case subscriptionRestored(productKey: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a previous subscription is successfully restored.

#### Subscription Restore Failed
```swift
case subscriptionRestoreFailed(triggerName: String, paywallTemplateName: String)
```
Triggered when an attempt to restore purchases fails.

#### Subscription Pending
```swift
case subscriptionPending(productKey: String, triggerName: String, paywallTemplateName: String)
```
Triggered when a subscription is in a pending state (e.g., waiting for approval).

### Paywall Lifecycle Events

#### Paywall Open
```swift
case paywallOpen(triggerName: String, paywallTemplateName: String, viewType: String)
```
Triggered when a paywall is successfully opened and displayed to the user.

View type maps to:
```swift
public enum PaywallOpenViewType : String {
    case presented = "presented" // via presentUpsell
    case triggered = "triggered" // shown via SwiftUI view modifier
    case embedded = "embedded" // paywall was manually embedded
}
```

#### Paywall Open Failed
```swift
case paywallOpenFailed(triggerName: String, paywallTemplateName: String)
```
Triggered when there's an error opening or displaying the paywall.

#### Paywall Close
```swift
case paywallClose(triggerName: String, paywallTemplateName: String)
```
Triggered when the paywall is closed programmatically.

#### Paywall Dismissed
```swift
case paywallDismissed(triggerName: String, paywallTemplateName: String, dismissAll: Bool = false)
```
Triggered when the user dismisses the paywall.

#### Paywall Skipped
```swift
case paywallSkipped(triggerName: String)
```
Triggered when a paywall open gets skipped for a trigger, due to a targeting or workflow configuration.

#### Paywall WebView Rendered
```swift
case paywallWebViewRendered(triggerName: String, paywallTemplateName: String, webviewRenderTimeTakenMS: UInt64? = nil)
```
Triggered when a WebView-based paywall has been successfully rendered.

### Configuration Events

#### Paywalls Download Success
```swift
case paywallsDownloadSuccess(configId: UUID, downloadTimeTakenMS: UInt64? = nil, imagesDownloadTimeTakenMS: UInt64? = nil, fontsDownloadTimeTakenMS: UInt64? = nil, bundleDownloadTimeMS: UInt64? = nil, numAttempts: Int? = nil)
```
Triggered when paywall configurations are successfully downloaded.

#### Paywalls Download Error
```swift
case paywallsDownloadError(error: String, numAttempts: Int? = nil)
```
Triggered when there's an error downloading paywall configurations.

#### User Allocated
```swift
case userAllocated(triggerName: String, experimentInfo: ExperimentInfo)
```
Triggered when a user is allocated to an experiment variant (fires once per trigger per session).

**Associated Values:**
- `triggerName` - The trigger that was allocated
- `experimentInfo` - Complete `ExperimentInfo` object with:
  - `experimentName`, `experimentId`, `experimentType` - Experiment metadata
  - `audienceId`, `audienceData` - Targeting criteria
  - `allocationMetadata` - Custom metadata
  - `chosenVariantDetails` - Variant allocation details (name, index, UUID)
  - `hashDetails` - User bucketing (bucket 1-100, hash method)

**Usage:**
```swift
func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
    switch event {
    case .userAllocated(let triggerName, let experimentInfo):
        print("Allocated to experiment: \(experimentInfo.experimentName ?? "unknown")")
        print("Variant: \(experimentInfo.chosenVariantDetails?.allocationIndex ?? 0)")
        print("Hash bucket: \(experimentInfo.hashDetails?.hashedUserIdBucket1To100 ?? 0)")
    default:
        break
    }
}
```