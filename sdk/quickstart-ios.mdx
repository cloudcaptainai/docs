---
title: "SDK Quickstart (iOS)"
description: "Integrate Helium into your iOS app"
icon: "code"
---

## **Background**

Get set up with the Helium SDK for iOS in 5 minutes. Reach out over your Helium slack channel, or email [founders@tryhelium.com](mailto:founders@tryhelium.com) for any questions.

## **Installation**

We recommend using Swift Package Manager (SPM), but if your project primarily uses Cocoapods it might make sense to install the Helium Cocoapod instead.

<Tabs>
  <Tab title="Swift Package Manager (SPM)">
    1. In Xcode, navigate to your project's **Package Dependencies:**

       ![Spm Add Pn](/images/spm-add.png)
    2. Click the **\+** button and search for the Helim package URL:

       ```
       https://github.com/cloudcaptainai/helium-swift.git
       ```
    3. Click **Add Package**.
    4. In the dialog that appears, make sure to add the **Helium** product to your appâ€™s main target:

       ![Spm Target Pn](/images/spm_target.png)
    5. _(Optional)_ If you are using RevenueCat to manage purchases, we recommended you also add **HeliumRevenueCat** to your target so that you can use our RevenueCatDelegate referenced below. Otherwise leave as **None** for the HeliumRevenueCat row.

    <Warning>
      The **HeliumRevenueCat** target includes [purchases-ios-spm](https://github.com/RevenueCat/purchases-ios-spm)  as a dependency, _not_ [purchases-ios](https://github.com/RevenueCat/purchases-ios) and you may encounter build issues if are using **purchases-ios** with SPM.
    </Warning>
    6. Select **Add Package** in the dialog and Helium should now be ready for import.
  </Tab>
  <Tab title="Cocoapod">
    Add the Helium Cocoapod with:

    ```shellscript
    pod install Helium
    ```

    Or by adding it to your Podfile:

    ```
    pod 'Helium', '~> 2.0'
    ```

    and running

    ```shellscript
    pod install
    ```
  </Tab>
</Tabs>

## Initialize Helium

Initialize the Helium SDK as early as possible in your app's lifecycle. Choose the appropriate location based on your app's architecture:

<Tabs>
  <Tab title="SwiftUI">
    ```swift
    @main
    struct MyApp: App {
        init() {
            // ** Call Helium initialize here **
        }

        var body: some Scene {
            WindowGroup {
                ContentView()
            }
        }
    }
    ```

    ### Import Helium

    ```swift
    import Helium
    import SwiftUI
    ```

    ### Call the `initialize` Method
  </Tab>
  <Tab title="SceneDelegate">
    ```swift
    class SceneDelegate: UIResponder, UIWindowSceneDelegate {

        var window: UIWindow?

        func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            // ** Call Helium initialize here **
        }
    }
    ```
  </Tab>
  <Tab title="AppDelegate">
    ```swift
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {

        var window: UIWindow?

        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
            // ** Call Helium initialize here **
            return true
        }
    }
    ```
  </Tab>
</Tabs>

```swift
Helium.shared.initialize(
    apiKey: "<your-helium-api-key>",
    heliumPaywallDelegate: YourHeliumPaywallDelegate(), // see next section
    fallbackPaywall: Text("Fallback shown"),
    revenueCatAppUserId: Purchases.shared.appUserID // RevenueCat ONLY
)
```

<ResponseField name="initialize" type="method">
  <Expandable title="properties">
    <ResponseField name="apiKey" type="string" required>
      You can create or retrieve your api key from [Account Settings](https://app.tryhelium.com/profile).
    </ResponseField>
    <ResponseField name="heliumPaywallDelegate" type="HeliumPaywallDelegate" required>
      Delegate to handle paywall events and callbacks (see next section)
    </ResponseField>
    <ResponseField name="fallbackPaywall" type="(any View)" required>
      Default view to display when paywall fails to load. fallbackAssetsConfig and fallbackPaywallPerTrigger will take precedence over this.
    </ResponseField>
    <ResponseField name="customUserId" type="String?">
      _(Optional)_ If set, a custom user id to use instead of Helium's. We'll use this id when forwarding to third party analytics services, so this can be used for attribution (e.g. an amplitude user id, or a custom user id from your own analytics service)
    </ResponseField>
    <ResponseField name="customAPIEndpoint" type="String?" deprecated>
      _(Optional)_ Custom API endpoint URL
    </ResponseField>
    <ResponseField name="customUserTraits" type="HeliumUserTraits?">
      _(Optional)_ Pass in custom user traits to be used for targeting, personalization, and dynamic content.
    </ResponseField>
    <ResponseField name="appAttributionToken" type="UUID?">
      _(Optional)_ Set this if you use a custom appAccountToken with your StoreKit purchases.
    </ResponseField>
    <ResponseField name="revenueCatAppUserId" type="String?">
      _(Optional)_ RevenueCat ONLY. Supply RevenueCat appUserID here (and initialize RevenueCat before Helium initialize).
    </ResponseField>
    <ResponseField name="fallbackBundleURL" type="URL?">
      _(Optional)_ The URL to a [fallback bundle](/guides/fallback-bundle) downloaded from the dashboard.
    </ResponseField>
    <ResponseField name="fallbackPaywallPerTrigger" type="[String: any View]?">
      _(Optional)_ Trigger-specific fallback views
    </ResponseField>
  </Expandable>
</ResponseField>

<Note>
  Helium's initialization is ran on a background thread, so you don't have to worry about it blocking your app's launch time. Helium will automatically retry downloads as needed for up to 90 seconds.
</Note>

<Accordion title="Additional Configurations">
  #### Passing in Custom User Traits

  HeliumUserTraits is a struct that defines the possible user traits that can be passed in. It can be created with any dictionary, as long as the key is a string and the value is a `Codable` type.

  ```swift
  let customUserTraits = HeliumUserTraits(traits: [
      "account_age": 100,
      "subscription_status": "active",
      "user_intent": "upgrade",
  ])
  ```

  #### Passing in a Custom User ID

  By default, Helium generates a UUID per app session and identifies each user \+ interaction with this. You can pass override this value with a custom user id (e.g. from a 3rd party analytics service)
  by passing it in as a parameter in `Helium.shared.initializeAndFetchVariants`, or by explicitly calling `Helium.shared.overrideUserId`:

  ```swift
  // Somewhere BEFORE initialize:
  Helium.shared.overrideUserId(newUserId: '<your-custom-user-id>');
  ```

  #### Checking Download Status

  After the initialization code above runs, you can check the status of the paywall configuration download using the `Helium.shared.downloadStatus()` method. This method returns a value of type `HeliumFetchedConfigStatus`, which is defined as follows:

  ```swift
  public enum HeliumFetchedConfigStatus: Codable {
      case notDownloadedYet
      case downloadSuccess(fetchedConfigId: UUID)
      case downloadFailure
  }
  ```

  `notDownloadedYet`: Indicates that the download has not been initiated or is still in progress.

  `downloadSuccess(fetchedConfigId: UUID)`: Indicates a successful download. The returned `fetchedConfigID` provides the UUID of the fetched configuration.

  `downloadFailure`: Indicates that the download attempt failed.

  You can use this to handle different states in your app, for example:

  ```swift
  switch Helium.shared.downloadStatus() {
      case .notDownloadedYet:
          print("Download not started or in progress")
      case .downloadSuccess(let configId):
          print("Download successful with config ID: \(configId)")
      case .downloadFailure:
          print("Download failed")
  }
  ```
</Accordion>

## HeliumPaywallDelegate

Create a subclass of `HeliumPaywallDelegate` or use one of our pre-built delegates. This class is responsible for handling the purchase logic for your paywalls.

<Tabs>
  <Tab title="StoreKitDelegate">
    Use the StoreKitDelegate to handle purchases using native StoreKit 2:

    ```swift
    import Helium

    let delegate = StoreKitDelegate(productIds: [
        "<product-id-1>",
        "<product-id-2>",
    ])
    ```

    If you would like to implement `onHeliumPaywallEvent`, simply create a subclass of StoreKitDelegate.
  </Tab>
  <Tab title="RevenueCatDelegate">
    ```swift
    import HeliumRevenueCat

    let delegate = RevenueCatDelegate(entitlementId: "<revenue-cat-entitlement-id>")
    ```

    If you would like to implement `onHeliumPaywallEvent`, simply create a subclass of RevenueCatDelegate. Make sure to initialize RevenueCat before initializing Helium or alternatively you can supply your RevenueCat API key to RevenueCatDelegate() and have Helium initialize RevenueCat for you.
  </Tab>
  <Tab title="Custom Delegate">
    ```swift
    public protocol HeliumPaywallDelegate: AnyObject {

    // [REQUIRED] - Trigger the purchase of a product with the following App Store Connect Product ID.
    // This method should return a HeliumPaywallTransactionStatus enum, described below.
    // Loading states/UI/UX here gets configured in the Helium dashboard, so this method should just trigger the purchase.
    func makePurchase(productId: String) async -> HeliumPaywallTransactionStatus

    // [OPTIONAL] - Restore any existing subscriptions.
    // This method should return a boolean indicating whether the restore was successful.
    // This method gets called if you've configured a CTA in the editor to restore purchases, which is recommended.
    func restorePurchases() async -> Bool

    // [OPTIONAL] Custom analytics/error logging for paywall/helium
    // related events can be added here.
    // By default, we log events to your analytics service (Amplitude, etc.), but you can override this method to add additional custom logging/handling.
    // For example, you can log failure events to a Sentry instance, or add custom alerts/notifications on certain paywall events here.
    func onHeliumPaywallEvent(event: HeliumPaywallEvent)
    }
    ```

    HeliumPaywallTransactionStatus is an enum that defines the possible states of a paywall transaction.

    ```swift
    import Helium

    public enum HeliumPaywallTransactionStatus {
        // if the subscription succeeded
        case purchased

        // if the subscription was cancelled
        case cancelled

        // if the subscription was abandoned
        case abandoned

        // if the subscription failed. Pass in the error as an argument for both logging and downstream handling.
        case failed(Error)

        // if the user restored their subscription
        case restored

        // if the subscription is 'pending' (requires action from developer)
        case pending
    }
    ```

    <Note>
      If you're using a custom delegate instead of the default StoreKit 2 delegate, please use `Product.heliumPurchase()` instead of Product.purchase().

      This will automatically set attribution information for revenue tracking.
    </Note>
    Example:

    ```swift
    open func makePurchase(productId: String) async -> HeliumPaywallTransactionStatus {
        do {
            guard let product: Product = productMappings[productId] else {
                print("[Helium] StoreKitDelegate - makePurchase could not find product!")
                return .failed(StoreKitDelegateError.cannotFindProduct)
            }

            let result = try await product.heliumPurchase()

            switch result {
            case .success(let verification):
                switch verification {
                case .verified(let transaction):
                    await transaction.finish()
                    return .purchased
                case .unverified(_, let error):
                    return .failed(error)
                }
            case .userCancelled:
                return .cancelled
            case .pending:
                return .pending
            @unknown default:
                return .failed(StoreKitDelegateError.unknownPurchaseResult)
            }
        } catch {
            print("[Helium] StoreKitDelegate - Purchase failed with error: \(error.localizedDescription)")
            return .failed(error)
        }
    }
    ```
  </Tab>
</Tabs>

## Presenting Paywalls

Now, anywhere in your iOS app, you can use the `triggerUpsell` modifier to (conditionally) trigger a Helium paywall\!

- You don't actually specify the paywall version name here - we load the paywall from the backend based on the trigger.
- What _is_ specified is a "trigger name". These trigger names should be **unique** across your app. User interactions with paywalls will be tracked and used to optimize the paywall for each trigger.

### Via SwiftUI ViewModifier

You can use the `.triggerUpsell` view modifier from any SwiftUI view. It can be provided with a boolean binding var parameter to control the visibility of the paywall.

```swift
struct ContentView: View {
    @State var isPresented: Bool = false
    var body: some View {
        VStack {
            Button {
                isPresented = true;
            } label: {
                Text("Show paywall")
            }

        }.triggerUpsell(isPresented: $isPresented, trigger: "showPaywallPress")
    }
}
```

### Via Programmatic invokation (UIKit/ViewController)

In addition to using the triggerUpsell modifier, you can also present upsells programmatically using the `presentUpsell(trigger:)` method. This is particularly useful when you need to show a paywall in response to a specific action or event in your app.

```swift
Button("Try Premium") {
    Helium.shared.presentUpsell(trigger: "postOnboardingButtonPress")
}
```

### Explicitly getting the Helium Paywall View

You can also explicitly get the Helium paywall view via `Helium.shared.upsellViewForTrigger`. This method takes a trigger and returns the paywall
as an `AnyView`.

```swift
let heliumView: AnyView = Helium.shared.upsellViewForTrigger(trigger: "postOnboardingButtonPress")
```

### Custom dismissal/navigation actions

By default, Helium uses a `DismissAction` to support dismissing the paywall. However, in cases where you want to control dismissal yourself (e.g. if you're using a custom ViewController, or a NavigationStack),
you can use `HeliumPaywallDelegate` to wire up dismissal (or any custom action\!) events from a given paywall.

To wire up actions, implement the `onCTAPressed` method as follows:

```swift

class YourHeliumPaywallDelegate: HeliumPaywallDelegate {
    
    func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
        switch (event) {
            case .ctaPressed(let ctaName, let triggerName, let paywallTemplateName): {
                if (ctaName == 'dismiss') {
                    // your custom dismissal action for this trigger
                }
            }
            ... other cases
        }
    }    

    // ...rest of your methods
}
```

How it works is that any component (e.g. an X out icon, decline text, etc.) can be remotely configured to be a wrapped in a `Button` with a name. When this button component
is tapped, we fire the delegate's `onCTAPressed` method with the button name. So, once you've implemented custom swift code from your delegate, you can remotely configure
components in the paywall to trigger those methods.

## Paywall Events

View the different types of paywall events [here](/sdk/helium-events).

## Testing

Docs here coming soon\! After integration, please message us directly to get set up with a test app \+ in-app test support.
