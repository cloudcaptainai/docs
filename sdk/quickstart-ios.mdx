---
title: "SDK Quickstart (iOS)"
description: "Integrate Helium into your iOS app"
icon: "/images/sdk/logos/apple-173-svgrepo-com.svg"
---

<Info>
  **Using an older SDK version?**
  
  If you're upgrading from SDK v2.x, check our [Migration Guide](/sdk-reference/migration-2-to-3) for breaking changes and upgrade instructions.
</Info>

## **Background**

Get set up with the Helium SDK for iOS. Reach out over your Helium slack channel or email [founders@tryhelium.com](mailto:founders@tryhelium.com) for any questions.

## **Installation**

We recommend using Swift Package Manager (SPM), but if your project primarily uses Cocoapods it might make sense to install the Helium Cocoapod instead.

<Tabs>
  <Tab title="Swift Package Manager (SPM)">
    1. In Xcode, navigate to your project's **Package Dependencies:**

       ![Spm Add Pn](/images/spm-add.png)
    2. Click the **\+** button and search for the Helium package URL:

       ```
       https://github.com/cloudcaptainai/helium-swift.git
       ```
    3. Click **Add Package**.
    4. In the dialog that appears, make sure to add the **Helium** product to your app's main target:

       ![Spm Target Pn](/images/spm_target.png)
    5. _(Optional)_ If you are using RevenueCat to manage purchases, we recommended you also add **HeliumRevenueCat** to your target so that you can use our RevenueCatDelegate referenced in the HeliumPaywallDelegate section of this guide. Otherwise leave as **None** for the HeliumRevenueCat row.

    <Warning>
      The **HeliumRevenueCat** target includes [purchases-ios-spm](https://github.com/RevenueCat/purchases-ios-spm) as a dependency, _not_ [purchases-ios](https://github.com/RevenueCat/purchases-ios) and you may encounter build issues if are using **purchases-ios** with SPM.
    </Warning>
    6. Select **Add Package** in the dialog and Helium should now be ready for import.
    7. Version: We recommend using an upToNextMajor rule to make sure you get non-breaking bug fixes. The latest stable version of helium-swift is **3.0.0** :

      ![Xcode 3 Dependency](/images/sdk/xcode_3_dependency.png)

  </Tab>
  <Tab title="Cocoapod">
    ### Option 1: Core functionality only

    Add this to your Podfile:

    ```ruby
    pod 'Helium', '~> 3.0'
    ```

    Then run:

    ```bash
    pod install
    ```

    ### Option 2: Core \+ RevenueCat

    <Note>
      Recommended if you are using RevenueCat to manage purchases.
    </Note>
    Add this to your Podfile:

    ```ruby
    pod 'Helium/RevenueCat', '~> 3.0'
    ```

    Then run:

    ```bash
    pod install
    ```
  </Tab>
</Tabs>

## Initialize Helium

Initialize the Helium SDK as early as possible in your app's lifecycle. Choose the appropriate location based on your app's architecture:

<Tabs>
  <Tab title="SwiftUI">
    ```swift
    @main
    struct MyApp: App {
        init() {
            // Call Helium.shared.initialize here (see example below)
        }

        var body: some Scene {
            WindowGroup {
                ContentView()
            }
        }
    }
    ```
  </Tab>
  <Tab title="SceneDelegate">
    ```swift
    class SceneDelegate: UIResponder, UIWindowSceneDelegate {

        var window: UIWindow?

        func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
            // Call Helium.shared.initialize here (see example below)
        }
    }
    ```
  </Tab>
  <Tab title="AppDelegate">
    ```swift
    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {

        var window: UIWindow?

        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
            // Call Helium.shared.initialize here (see example below)
            return true
        }
    }
    ```
  </Tab>
</Tabs>

Add necessary imports:

```swift
import Helium
import SwiftUI
```

And initialize Helium in the location referenced above:

```swift
// Create fallback configuration (required)
let fallbackConfig = HeliumFallbackConfig.withFallbackView(
    Text("Fallback shown")
)

// Or use a fallback bundle (recommended)
let fallbackBundleURL = Bundle.main.url(forResource: "fallback-bundle", withExtension: "json")
let fallbackConfig = HeliumFallbackConfig.withFallbackBundle(fallbackBundleURL)

Helium.shared.initialize(
    apiKey: "<your-helium-api-key>",
    heliumPaywallDelegate: YourHeliumPaywallDelegate(), // see next section
    fallbackConfig: fallbackConfig,
    revenueCatAppUserId: Purchases.shared.appUserID // RevenueCat ONLY
)
```


<ResponseField name="Helium.shared.initialize" type="method">
  <Expandable title="properties">
    <ResponseField name="apiKey" type="string" required>
      You can create or retrieve your api key from [Account Settings](https://app.tryhelium.com/profile).
    </ResponseField>
    <ResponseField name="heliumPaywallDelegate" type="HeliumPaywallDelegate" required>
      Delegate to handle paywall events and callbacks (see next section)
    </ResponseField>
    <ResponseField name="fallbackConfig" type="HeliumFallbackConfig" required>
      Fallback configuration with either a view or bundle URL. Required parameter.
    </ResponseField>
    <ResponseField name="customUserId" type="String?">
      _(Optional)_ If set, a custom user id to use instead of Helium's. We'll use this id when forwarding to third party analytics services, so this can be used for attribution (e.g. an amplitude user id, or a custom user id from your own analytics service)
    </ResponseField>
    <ResponseField name="customUserTraits" type="HeliumUserTraits?">
      _(Optional)_ Pass in custom user traits to be used for targeting, personalization, and dynamic content. It can be created with any dictionary, as long as the key is a string and the value is a `Codable` type.

      ```swift
      let customUserTraits = HeliumUserTraits(traits: [
          "testTrait": 1,
          "account_age_in_days": "20",
      ])
      ```
    </ResponseField>
    <ResponseField name="appAttributionToken" type="UUID?">
      _(Optional)_ Set this if you use a custom appAccountToken with your StoreKit purchases.
    </ResponseField>
    <ResponseField name="revenueCatAppUserId" type="String?">
      _(Optional)_ RevenueCat ONLY. Supply RevenueCat appUserID here (and initialize RevenueCat before Helium initialize).
    </ResponseField>
  </Expandable>
</ResponseField>

<Note>
  Helium's initialization is ran on a background thread, so you don't have to worry about it blocking your app's launch time. Helium will automatically retry downloads as needed for up to 90 seconds.
</Note>

<Accordion title="Custom User ID and Custom User Traits">
  You can provide a custom user ID and custom user traits in the `initialize` method or by using `Helium.shared.overrideUserId`. Ideally this will be called before `initialize` is called to ensure consistency in analytics events.

  ```swift
  Helium.shared.overrideUserId(
      newUserId: "<your-custom-user-id>",
      traits: HeliumUserTraits? = nil
  );
  ```
</Accordion>

<Accordion title="Checking Download Status">
  You can check the status of the paywall configuration download using the `Helium.shared.getDownloadStatus()` method. This method returns a value of type `HeliumFetchedConfigStatus`, which is defined as follows:

  ```swift
  public enum HeliumFetchedConfigStatus: String, Codable, Equatable {
      case notDownloadedYet
      case inProgress
      case downloadSuccess
      case downloadFailure
  }
  ```

  You can also simply check if paywalls have been successfully downloaded with `Helium.shared.paywallsLoaded()`.
</Accordion>

<Accordion title="Get Paywall Info By Trigger">
  Retrieve basic information about the paywall ready to show for a specific trigger
  with `Helium.shared.getPaywallInfo(trigger: String)` which returns:

  ```swift
  public struct PaywallInfo {
      public let paywallTemplateName: String
      public let shouldShow: Bool
  }
  ```
</Accordion>

## HeliumPaywallDelegate

Create a subclass of `HeliumPaywallDelegate` or use one of our pre-built delegates. This class is responsible for handling the purchase logic for your paywalls and handling [Helium Events](/sdk/helium-events).

<Tabs>
  <Tab title="StoreKitDelegate">
    Use the StoreKitDelegate to handle purchases using native StoreKit 2:

    ```swift
    import Helium

    let delegate = StoreKitDelegate(productIds: [
        "<product-id-1>",
        "<product-id-2>",
    ])
    ```

    To handle [Helium Events](/sdk/helium-events), simply create a subclass of StoreKitDelegate and override `onHeliumPaywallEvent`:

    ```swift
    class MyStoreKitDelegate: StoreKitDelegate {
        override func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
            switch event {
            case .paywallOpen(let triggerName, let paywallTemplateName, let viewType):
                break
            case .paywallClose(let triggerName, let paywallTemplateName):
                break
            case .paywallDismissed:
                break
            default:
                break
            }
        }
    }
    ```
  </Tab>
  <Tab title="RevenueCatDelegate">
    You can use the pre-built RevenueCatDelegate to handle purchases if your app is using RevenueCat:

    ```swift
    import HeliumRevenueCat

    // You must have an offering set up with RevenueCat for this delegate:
    let delegate = RevenueCatDelegate(entitlementId: "<revenue-cat-entitlement-id>")

    // Alternatively you can specify product IDs:
    let delegate = RevenueCatDelegate(
        entitlementId: "<revenue-cat-entitlement-id>",
        productIds: ["<product-id-1>", "<product-id-2>"]
    )
    ```

    <Note>
      Make sure to initialize RevenueCat _before_ initializing Helium\! Or alternatively you can supply your RevenueCat API key to RevenueCatDelegate() and have Helium initialize RevenueCat for you.
    </Note>
    To handle [Helium Events](/sdk/helium-events), simply create a subclass of RevenueCatDelegate and override `onHeliumPaywallEvent`:

    ```swift
    class MyRevenueCatDelegate: RevenueCatDelegate {
        override func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
            switch event {
            case .paywallOpen(let triggerName, let paywallTemplateName, let viewType):
                break
            case .paywallClose(let triggerName, let paywallTemplateName):
                break
            case .paywallDismissed:
                break
            default:
                break
            }
        }
    }
    ```
  </Tab>
  <Tab title="Custom Delegate">
    You can also create a custom delegate and implement your own purchase logic. You can look at our `StoreKitDelegate` and `RevenueCatDelegate` in the SDK for examples (these delegates are also visible below).

    The `HeliumPaywallDelegate` is defined as follows:

    ```swift
    public protocol HeliumPaywallDelegate: AnyObject {

        // Execute the purchase of a product given the product ID.
        func makePurchase(productId: String) async -> HeliumPaywallTransactionStatus

        // (Optional) - Restore any existing subscriptions.
        // Return a boolean indicating whether the restore was successful.
        func restorePurchases() async -> Bool

        // (Optional) - Handle Helium Events
        func onHeliumPaywallEvent(event: HeliumPaywallEvent)
    }
    ```

    `HeliumPaywallTransactionStatus` is an enum that defines the possible states of a paywall transaction:

    ```swift
    public enum HeliumPaywallTransactionStatus {
        case purchased
        case cancelled
        case failed(Error)
        case restored
        case pending
    }
    ```

    Visit [Helium Events](/sdk/helium-events) for details on the different Helium paywall events.

    <Note>
      When executing the purchase via StoreKit 2 (recommended over StoreKit 1), please use `Product.heliumPurchase()` instead of `Product.purchase()`. For example:

      `let result = try await product.heliumPurchase()`

      This will automatically set attribution information for [revenue tracking](/guides/revenue-reporting).
    </Note>
    <Accordion title="StoreKitDelegate Example">
      ```swift
      /// A simple HeliumPaywallDelegate implementation that uses StoreKit 2 under the hood.
      @available(iOS 15.0, *)
      open class StoreKitDelegate: HeliumPaywallDelegate {

          private(set) var productMappings: [String: Product] = [:];

          public init(productIds: [String]) {
              Task {
                  do {
                      let fetchedProducts = try await Product.products(for: productIds)
                      var mappings: [String: Product] = [:];
                      // First create the direct mappings from test product IDs
                      for fetchedProduct in fetchedProducts {
                          mappings[fetchedProduct.id] = fetchedProduct;
                      }
                      productMappings = mappings
                  } catch {
                      print("[Helium] StoreKitDelegate - error fetching products. \(error)")
                  }
              }
          }

          open func makePurchase(productId: String) async -> HeliumPaywallTransactionStatus {
              do {
                  guard let product: Product = productMappings[productId] else {
                      print("[Helium] StoreKitDelegate - makePurchase could not find product!")
                      return .failed(StoreKitDelegateError.cannotFindProduct)
                  }

                  let result = try await product.heliumPurchase()

                  switch result {
                  case .success(let verification):
                      switch verification {
                      case .verified(let transaction):
                          await transaction.finish()
                          return .purchased
                      case .unverified(_, let error):
                          return .failed(error)
                      }
                  case .userCancelled:
                      return .cancelled
                  case .pending:
                      return .pending
                  @unknown default:
                      return .failed(StoreKitDelegateError.unknownPurchaseResult)
                  }
              } catch {
                  print("[Helium] StoreKitDelegate - Purchase failed with error: \(error.localizedDescription)")
                  return .failed(error)
              }
          }

          open func restorePurchases() async -> Bool {
              for await result in Transaction.currentEntitlements {
                  if case .verified = result {
                      return true
                  }
              }
              return false
          }

          open func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
              // Override in a subclass if desired
          }
      }
      ```
    </Accordion>
    <Accordion title="RevenueCatDelegate Example">
      ```swift
      /// A HeliumPaywallDelegate implementation specifically intended for apps that use RevenueCat to handle
      /// in-app purchases & subscriptions. Do not use if you don't plan on configuring your purchases with RevenueCat.
      open class RevenueCatDelegate: HeliumPaywallDelegate {

          public let entitlementId: String
          private var offerings: Offerings?
          private var products: [StoreProduct]?

          private func configureRevenueCat(revenueCatApiKey: String) {
              Purchases.configure(withAPIKey: revenueCatApiKey, appUserID: HeliumIdentityManager.shared.getHeliumPersistentId())
          }

          /// Initialize the delegate.
          ///
          /// - Parameter entitlementId: The id of the [entitlement](https://www.revenuecat.com/docs/getting-started/entitlements) that you have configured with RevenueCat.
          /// - Parameter revenueCatApiKey: (Optional). Only set if you want Helium to handle RevenueCat initialization for you. Otherwise make sure to [initialize RevenueCat](https://www.revenuecat.com/docs/getting-started/quickstart#initialize-and-configure-the-sdk) before initializing Helium.
          public init(
              entitlementId: String,
              revenueCatApiKey: String? = nil
          ) {
              self.entitlementId = entitlementId

              if let revenueCatApiKey {
                  configureRevenueCat(revenueCatApiKey: revenueCatApiKey)
              }

              Task {
                  do {
                      offerings = try await Purchases.shared.offerings()
                  } catch {
                      print("[Helium] RevenueCatDelegate - Failed to load RevenueCat offerings: \(error.localizedDescription)")
                  }
              }
          }

          /// Initialize the delegate.
          ///
          /// - Parameter entitlementId: The id of the [entitlement](https://www.revenuecat.com/docs/getting-started/entitlements) that you have configured with RevenueCat.
          /// - Parameter productIds: A list of product IDs, configured in the App Store, that can be purchased via a Helium paywall.
          /// - Parameter revenueCatApiKey: (Optional). Only set if you want Helium to handle RevenueCat initialization for you. Otherwise make sure to [initialize RevenueCat](https://www.revenuecat.com/docs/getting-started/quickstart#initialize-and-configure-the-sdk) before initializing Helium.
          public init(
              entitlementId: String,
              productIds: [String],
              revenueCatApiKey: String? = nil
          ) {
              self.entitlementId = entitlementId

              if let revenueCatApiKey {
                  configureRevenueCat(revenueCatApiKey: revenueCatApiKey)
              }

              Task {
                  do {
                      products = try await Purchases.shared.products(productIds)
                  } catch {
                      print("[Helium] RevenueCatDelegate - Failed to load RevenueCat products: \(error.localizedDescription)")
                  }
              }
          }

          open func makePurchase(productId: String) async -> HeliumPaywallTransactionStatus {
              do {
                  var result: PurchaseResultData? = nil

                  if let offerings {
                      var packageToPurchase: Package? = nil

                      for (_, offering) in offerings.all {
                          for package in offering.availablePackages {
                              if package.storeProduct.productIdentifier == productId {
                                  packageToPurchase = package
                                  break
                              }
                          }
                          if packageToPurchase != nil {
                              break
                          }
                      }

                      guard let package = packageToPurchase else {
                          return .failed(RevenueCatDelegateError.cannotFindProductViaOffering)
                      }

                      result = try await Purchases.shared.purchase(package: package)
                  }

                  if let products, result == nil {
                      let productToPurchase = products.first { $0.productIdentifier == productId }
                      guard let product = productToPurchase else {
                          return .failed(RevenueCatDelegateError.cannotFindProduct)
                      }

                      result = try await Purchases.shared.purchase(product: product)
                  }

                  guard let result else {
                      return .failed(RevenueCatDelegateError.unexpected)
                  }

                  if result.userCancelled {
                      return .cancelled
                  }

                  if result.customerInfo.entitlements[entitlementId]?.isActive == true {
                      return .purchased
                  } else {
                      return .failed(RevenueCatDelegateError.purchaseNotVerified)
                  }
              } catch {
                  return .failed(error)
              }
          }

          open func restorePurchases() async -> Bool {
              do {
                  let customerInfo = try await Purchases.shared.restorePurchases()
                  return customerInfo.entitlements[entitlementId]?.isActive == true
              } catch {
                  return false
              }
          }

          open func onHeliumPaywallEvent(event: HeliumPaywallEvent) {
              // Override in a subclass if desired
          }
      }
      ```
    </Accordion>
  </Tab>
</Tabs>

## Presenting Paywalls

Now, anywhere in your iOS app, you can show a paywall in one of 3 ways.

### Show it as a full screen modal

Call `Helium.shared.presentUpsell(trigger:)` when you want to show the paywall. For example:

```swift
Button("Try Premium") {
    Helium.shared.presentUpsell(trigger: "post_onboarding")
}
```

### Attach it to a SwiftUI view as a ViewModifier

You can use the `.triggerUpsell` view modifier from any SwiftUI view:

```swift
struct ContentView: View {
    @State var isPresented: Bool = false
    var body: some View {
        VStack {
            Button {
                isPresented = true;
            } label: {
                Text("Show paywall")
            }

        }.triggerUpsell(isPresented: $isPresented, trigger: "post_onboarding")
    }
}
```

### Explicitly embed the Helium Paywall View

You can also explicitly get the Helium paywall view via `Helium.shared.upsellViewForTrigger`. This method takes a trigger and returns the paywall as an `AnyView`.

```swift
let heliumView: AnyView = Helium.shared.upsellViewForTrigger(trigger: "post_onboarding")
```

<Note>
  You'll need to handle presentation and dismissal yourself if you use this way of displaying paywalls. You can do so through [Helium Events](/sdk/helium-events).
</Note>

## Add some paywall event handlers

Helium emits various events related to paywall status, and paywall actions during the course of an app's session. You can handle these events using one of two methods:

<Tabs>
  <Tab title="PaywallEventHandlers (trigger specific callbacks)">
    Pass event handlers directly to `presentUpsell`, which in 3.0.0 now accepts an object of type `PaywallEventHandlers()`. You can chain a subset of handlers to this with builder syntax:

    ```swift
    Helium.shared.presentUpsell(
        trigger: "premium_features",
        eventHandlers: PaywallEventHandlers()
            .onOpen { event in
                print("Paywall opened: \(event.paywallName)")
            }
            .onClose { event in
                print("Paywall closed: \(event.paywallName)")
            }
            .onPurchaseSucceeded { event in
                print("Purchase successful: \(event.productId)")
            }
    )
    ```

    Only the `onOpen`, `onClose`, `onDismiss`, and `onPurchaseSucceeded` can be specified this way.

    <Note>
      **Event Timing:**
      - `onDismiss` is triggered only when a user manually dismisses a paywall (from an X button, "no thanks", etc.)
      - `onClose` is triggered both when the paywall got manually dismissed OR when a successful purchase triggers closing the paywall
      - `onPurchaseSucceeded` is triggered when a purchase completes successfully
      
      **Usage Guidelines:**
      - Use `onDismiss` for post-paywall navigation when the paywall is dismissed but a user's entitlement hasn't changed
      - Use `onPurchaseSucceeded` for your post purchase flow (e.g., a premium onboarding navigation)
      - Use `onClose` when you need to handle logic when the paywall closed, regardless of reason
    </Note>
  </Tab>
  <Tab title="HeliumPaywallDelegate (global handlers)">
    Use the `HeliumPaywallDelegate`'s `onPaywallEvent` method. This will apply to _all_ triggers:

    ```swift
    // Your delegate, that extends either StoreKitDelegate (if using SK 2), RevenueCatDelegate (if using RevenueCat), or HeliumPaywallDelegate (if you need custom purchase logic/need to override HeliumPaywallDelegate)
    class MyDelegate: StoreKitDelegate {
        override func onPaywallEvent(_ event: PaywallEvent) {
            switch event {
            case let openEvent as PaywallOpenEvent:
                print("Opened: \(openEvent.paywallName)")
            case let closeEvent as PaywallCloseEvent:
                print("Closed: \(closeEvent.paywallName)")
            case let purchaseEvent as PurchaseSucceededEvent:
                print("Purchased: \(purchaseEvent.productId)")
            case let dismissEvent as PaywallDismissedEvent:
                print("Dismissed: \(dismissEvent.triggerName)")
            default:
                break
            }
        }
    }
    ```

    This approach allows you to handle all paywall events in a centralized location and supports all event types available in the SDK.
  </Tab>
</Tabs>

## Testing

Docs here coming soon\! After integration, please message us directly to get set up with a test app \+ in-app test support.